// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: VrSmartHomeData.proto

#ifndef PROTOBUF_VrSmartHomeData_2eproto__INCLUDED
#define PROTOBUF_VrSmartHomeData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace navi {
namespace VoiceRecog {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_VrSmartHomeData_2eproto();
void protobuf_AssignDesc_VrSmartHomeData_2eproto();
void protobuf_ShutdownFile_VrSmartHomeData_2eproto();

class APIRequest;
class ApiParam;
class ApiData;
class ApiLast;
class ApiHeart;
class ApiCancel;
class ApiThirdData;
class APIResponse;
class ASRResult;

enum APIReqType {
  API_REQ_TYPE_PARAM = 1,
  API_REQ_TYPE_DATA = 2,
  API_REQ_TYPE_LAST = 3,
  API_REQ_TYPE_CANCEL = 4,
  API_REQ_TYPE_THIRD_DATA = 5
};
bool APIReqType_IsValid(int value);
const APIReqType APIReqType_MIN = API_REQ_TYPE_PARAM;
const APIReqType APIReqType_MAX = API_REQ_TYPE_THIRD_DATA;
const int APIReqType_ARRAYSIZE = APIReqType_MAX + 1;

enum APIRespType {
  API_RESP_TYPE_MIDDLE = 1,
  API_RESP_TYPE_RES = 2,
  API_RESP_TYPE_THIRD = 3,
  API_RESP_TYPE_HEART = 4,
  API_RESP_TYPE_LAST = 5
};
bool APIRespType_IsValid(int value);
const APIRespType APIRespType_MIN = API_RESP_TYPE_MIDDLE;
const APIRespType APIRespType_MAX = API_RESP_TYPE_LAST;
const int APIRespType_ARRAYSIZE = APIRespType_MAX + 1;

// ===================================================================

class APIRequest : public ::google::protobuf::MessageLite {
 public:
  APIRequest();
  virtual ~APIRequest();

  APIRequest(const APIRequest& from);

  inline APIRequest& operator=(const APIRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const APIRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const APIRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(APIRequest* other);

  // implements Message ----------------------------------------------

  APIRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const APIRequest& from);
  void MergeFrom(const APIRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .navi.VoiceRecog.APIReqType api_req_type = 1;
  inline bool has_api_req_type() const;
  inline void clear_api_req_type();
  static const int kApiReqTypeFieldNumber = 1;
  inline ::navi::VoiceRecog::APIReqType api_req_type() const;
  inline void set_api_req_type(::navi::VoiceRecog::APIReqType value);

  // optional .navi.VoiceRecog.ApiParam param = 2;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 2;
  inline const ::navi::VoiceRecog::ApiParam& param() const;
  inline ::navi::VoiceRecog::ApiParam* mutable_param();
  inline ::navi::VoiceRecog::ApiParam* release_param();
  inline void set_allocated_param(::navi::VoiceRecog::ApiParam* param);

  // optional .navi.VoiceRecog.ApiData data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::navi::VoiceRecog::ApiData& data() const;
  inline ::navi::VoiceRecog::ApiData* mutable_data();
  inline ::navi::VoiceRecog::ApiData* release_data();
  inline void set_allocated_data(::navi::VoiceRecog::ApiData* data);

  // optional .navi.VoiceRecog.ApiLast last = 4;
  inline bool has_last() const;
  inline void clear_last();
  static const int kLastFieldNumber = 4;
  inline const ::navi::VoiceRecog::ApiLast& last() const;
  inline ::navi::VoiceRecog::ApiLast* mutable_last();
  inline ::navi::VoiceRecog::ApiLast* release_last();
  inline void set_allocated_last(::navi::VoiceRecog::ApiLast* last);

  // optional .navi.VoiceRecog.ApiCancel cancel = 5;
  inline bool has_cancel() const;
  inline void clear_cancel();
  static const int kCancelFieldNumber = 5;
  inline const ::navi::VoiceRecog::ApiCancel& cancel() const;
  inline ::navi::VoiceRecog::ApiCancel* mutable_cancel();
  inline ::navi::VoiceRecog::ApiCancel* release_cancel();
  inline void set_allocated_cancel(::navi::VoiceRecog::ApiCancel* cancel);

  // optional .navi.VoiceRecog.ApiThirdData third_data = 6;
  inline bool has_third_data() const;
  inline void clear_third_data();
  static const int kThirdDataFieldNumber = 6;
  inline const ::navi::VoiceRecog::ApiThirdData& third_data() const;
  inline ::navi::VoiceRecog::ApiThirdData* mutable_third_data();
  inline ::navi::VoiceRecog::ApiThirdData* release_third_data();
  inline void set_allocated_third_data(::navi::VoiceRecog::ApiThirdData* third_data);

  // @@protoc_insertion_point(class_scope:navi.VoiceRecog.APIRequest)
 private:
  inline void set_has_api_req_type();
  inline void clear_has_api_req_type();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_last();
  inline void clear_has_last();
  inline void set_has_cancel();
  inline void clear_has_cancel();
  inline void set_has_third_data();
  inline void clear_has_third_data();

  ::navi::VoiceRecog::ApiParam* param_;
  ::navi::VoiceRecog::ApiData* data_;
  ::navi::VoiceRecog::ApiLast* last_;
  ::navi::VoiceRecog::ApiCancel* cancel_;
  ::navi::VoiceRecog::ApiThirdData* third_data_;
  int api_req_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_VrSmartHomeData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_VrSmartHomeData_2eproto();
  #endif
  friend void protobuf_AssignDesc_VrSmartHomeData_2eproto();
  friend void protobuf_ShutdownFile_VrSmartHomeData_2eproto();

  void InitAsDefaultInstance();
  static APIRequest* default_instance_;
};
// -------------------------------------------------------------------

class ApiParam : public ::google::protobuf::MessageLite {
 public:
  ApiParam();
  virtual ~ApiParam();

  ApiParam(const ApiParam& from);

  inline ApiParam& operator=(const ApiParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ApiParam& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ApiParam* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ApiParam* other);

  // implements Message ----------------------------------------------

  ApiParam* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ApiParam& from);
  void MergeFrom(const ApiParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 sample_rate = 1;
  inline bool has_sample_rate() const;
  inline void clear_sample_rate();
  static const int kSampleRateFieldNumber = 1;
  inline ::google::protobuf::int32 sample_rate() const;
  inline void set_sample_rate(::google::protobuf::int32 value);

  // required string format = 2;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 2;
  inline const ::std::string& format() const;
  inline void set_format(const ::std::string& value);
  inline void set_format(const char* value);
  inline void set_format(const char* value, size_t size);
  inline ::std::string* mutable_format();
  inline ::std::string* release_format();
  inline void set_allocated_format(::std::string* format);

  // optional bool early_return = 3;
  inline bool has_early_return() const;
  inline void clear_early_return();
  static const int kEarlyReturnFieldNumber = 3;
  inline bool early_return() const;
  inline void set_early_return(bool value);

  // required string imei = 4;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 4;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // required int32 home_link_type = 5;
  inline bool has_home_link_type() const;
  inline void clear_home_link_type();
  static const int kHomeLinkTypeFieldNumber = 5;
  inline ::google::protobuf::int32 home_link_type() const;
  inline void set_home_link_type(::google::protobuf::int32 value);

  // required string asr_backend_type = 6;
  inline bool has_asr_backend_type() const;
  inline void clear_asr_backend_type();
  static const int kAsrBackendTypeFieldNumber = 6;
  inline const ::std::string& asr_backend_type() const;
  inline void set_asr_backend_type(const ::std::string& value);
  inline void set_asr_backend_type(const char* value);
  inline void set_asr_backend_type(const char* value, size_t size);
  inline ::std::string* mutable_asr_backend_type();
  inline ::std::string* release_asr_backend_type();
  inline void set_allocated_asr_backend_type(::std::string* asr_backend_type);

  // @@protoc_insertion_point(class_scope:navi.VoiceRecog.ApiParam)
 private:
  inline void set_has_sample_rate();
  inline void clear_has_sample_rate();
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_early_return();
  inline void clear_has_early_return();
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_home_link_type();
  inline void clear_has_home_link_type();
  inline void set_has_asr_backend_type();
  inline void clear_has_asr_backend_type();

  ::std::string* format_;
  ::google::protobuf::int32 sample_rate_;
  bool early_return_;
  ::std::string* imei_;
  ::std::string* asr_backend_type_;
  ::google::protobuf::int32 home_link_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_VrSmartHomeData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_VrSmartHomeData_2eproto();
  #endif
  friend void protobuf_AssignDesc_VrSmartHomeData_2eproto();
  friend void protobuf_ShutdownFile_VrSmartHomeData_2eproto();

  void InitAsDefaultInstance();
  static ApiParam* default_instance_;
};
// -------------------------------------------------------------------

class ApiData : public ::google::protobuf::MessageLite {
 public:
  ApiData();
  virtual ~ApiData();

  ApiData(const ApiData& from);

  inline ApiData& operator=(const ApiData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ApiData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ApiData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ApiData* other);

  // implements Message ----------------------------------------------

  ApiData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ApiData& from);
  void MergeFrom(const ApiData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 len = 1;
  inline bool has_len() const;
  inline void clear_len();
  static const int kLenFieldNumber = 1;
  inline ::google::protobuf::uint32 len() const;
  inline void set_len(::google::protobuf::uint32 value);

  // required bytes post_data = 2;
  inline bool has_post_data() const;
  inline void clear_post_data();
  static const int kPostDataFieldNumber = 2;
  inline const ::std::string& post_data() const;
  inline void set_post_data(const ::std::string& value);
  inline void set_post_data(const char* value);
  inline void set_post_data(const void* value, size_t size);
  inline ::std::string* mutable_post_data();
  inline ::std::string* release_post_data();
  inline void set_allocated_post_data(::std::string* post_data);

  // @@protoc_insertion_point(class_scope:navi.VoiceRecog.ApiData)
 private:
  inline void set_has_len();
  inline void clear_has_len();
  inline void set_has_post_data();
  inline void clear_has_post_data();

  ::std::string* post_data_;
  ::google::protobuf::uint32 len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_VrSmartHomeData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_VrSmartHomeData_2eproto();
  #endif
  friend void protobuf_AssignDesc_VrSmartHomeData_2eproto();
  friend void protobuf_ShutdownFile_VrSmartHomeData_2eproto();

  void InitAsDefaultInstance();
  static ApiData* default_instance_;
};
// -------------------------------------------------------------------

class ApiLast : public ::google::protobuf::MessageLite {
 public:
  ApiLast();
  virtual ~ApiLast();

  ApiLast(const ApiLast& from);

  inline ApiLast& operator=(const ApiLast& from) {
    CopyFrom(from);
    return *this;
  }

  static const ApiLast& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ApiLast* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ApiLast* other);

  // implements Message ----------------------------------------------

  ApiLast* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ApiLast& from);
  void MergeFrom(const ApiLast& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:navi.VoiceRecog.ApiLast)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_VrSmartHomeData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_VrSmartHomeData_2eproto();
  #endif
  friend void protobuf_AssignDesc_VrSmartHomeData_2eproto();
  friend void protobuf_ShutdownFile_VrSmartHomeData_2eproto();

  void InitAsDefaultInstance();
  static ApiLast* default_instance_;
};
// -------------------------------------------------------------------

class ApiHeart : public ::google::protobuf::MessageLite {
 public:
  ApiHeart();
  virtual ~ApiHeart();

  ApiHeart(const ApiHeart& from);

  inline ApiHeart& operator=(const ApiHeart& from) {
    CopyFrom(from);
    return *this;
  }

  static const ApiHeart& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ApiHeart* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ApiHeart* other);

  // implements Message ----------------------------------------------

  ApiHeart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ApiHeart& from);
  void MergeFrom(const ApiHeart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:navi.VoiceRecog.ApiHeart)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_VrSmartHomeData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_VrSmartHomeData_2eproto();
  #endif
  friend void protobuf_AssignDesc_VrSmartHomeData_2eproto();
  friend void protobuf_ShutdownFile_VrSmartHomeData_2eproto();

  void InitAsDefaultInstance();
  static ApiHeart* default_instance_;
};
// -------------------------------------------------------------------

class ApiCancel : public ::google::protobuf::MessageLite {
 public:
  ApiCancel();
  virtual ~ApiCancel();

  ApiCancel(const ApiCancel& from);

  inline ApiCancel& operator=(const ApiCancel& from) {
    CopyFrom(from);
    return *this;
  }

  static const ApiCancel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ApiCancel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ApiCancel* other);

  // implements Message ----------------------------------------------

  ApiCancel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ApiCancel& from);
  void MergeFrom(const ApiCancel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:navi.VoiceRecog.ApiCancel)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_VrSmartHomeData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_VrSmartHomeData_2eproto();
  #endif
  friend void protobuf_AssignDesc_VrSmartHomeData_2eproto();
  friend void protobuf_ShutdownFile_VrSmartHomeData_2eproto();

  void InitAsDefaultInstance();
  static ApiCancel* default_instance_;
};
// -------------------------------------------------------------------

class ApiThirdData : public ::google::protobuf::MessageLite {
 public:
  ApiThirdData();
  virtual ~ApiThirdData();

  ApiThirdData(const ApiThirdData& from);

  inline ApiThirdData& operator=(const ApiThirdData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ApiThirdData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ApiThirdData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ApiThirdData* other);

  // implements Message ----------------------------------------------

  ApiThirdData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ApiThirdData& from);
  void MergeFrom(const ApiThirdData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 len = 1;
  inline bool has_len() const;
  inline void clear_len();
  static const int kLenFieldNumber = 1;
  inline ::google::protobuf::uint32 len() const;
  inline void set_len(::google::protobuf::uint32 value);

  // required bytes third_data = 2;
  inline bool has_third_data() const;
  inline void clear_third_data();
  static const int kThirdDataFieldNumber = 2;
  inline const ::std::string& third_data() const;
  inline void set_third_data(const ::std::string& value);
  inline void set_third_data(const char* value);
  inline void set_third_data(const void* value, size_t size);
  inline ::std::string* mutable_third_data();
  inline ::std::string* release_third_data();
  inline void set_allocated_third_data(::std::string* third_data);

  // optional string type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:navi.VoiceRecog.ApiThirdData)
 private:
  inline void set_has_len();
  inline void clear_has_len();
  inline void set_has_third_data();
  inline void clear_has_third_data();
  inline void set_has_type();
  inline void clear_has_type();

  ::std::string* third_data_;
  ::std::string* type_;
  ::google::protobuf::uint32 len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_VrSmartHomeData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_VrSmartHomeData_2eproto();
  #endif
  friend void protobuf_AssignDesc_VrSmartHomeData_2eproto();
  friend void protobuf_ShutdownFile_VrSmartHomeData_2eproto();

  void InitAsDefaultInstance();
  static ApiThirdData* default_instance_;
};
// -------------------------------------------------------------------

class APIResponse : public ::google::protobuf::MessageLite {
 public:
  APIResponse();
  virtual ~APIResponse();

  APIResponse(const APIResponse& from);

  inline APIResponse& operator=(const APIResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const APIResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const APIResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(APIResponse* other);

  // implements Message ----------------------------------------------

  APIResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const APIResponse& from);
  void MergeFrom(const APIResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .navi.VoiceRecog.APIRespType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::navi::VoiceRecog::APIRespType type() const;
  inline void set_type(::navi::VoiceRecog::APIRespType value);

  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required int32 err_no = 3;
  inline bool has_err_no() const;
  inline void clear_err_no();
  static const int kErrNoFieldNumber = 3;
  inline ::google::protobuf::int32 err_no() const;
  inline void set_err_no(::google::protobuf::int32 value);

  // optional string err_msg = 4;
  inline bool has_err_msg() const;
  inline void clear_err_msg();
  static const int kErrMsgFieldNumber = 4;
  inline const ::std::string& err_msg() const;
  inline void set_err_msg(const ::std::string& value);
  inline void set_err_msg(const char* value);
  inline void set_err_msg(const char* value, size_t size);
  inline ::std::string* mutable_err_msg();
  inline ::std::string* release_err_msg();
  inline void set_allocated_err_msg(::std::string* err_msg);

  // optional .navi.VoiceRecog.ASRResult result = 5;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 5;
  inline const ::navi::VoiceRecog::ASRResult& result() const;
  inline ::navi::VoiceRecog::ASRResult* mutable_result();
  inline ::navi::VoiceRecog::ASRResult* release_result();
  inline void set_allocated_result(::navi::VoiceRecog::ASRResult* result);

  // optional .navi.VoiceRecog.ApiThirdData third_data = 6;
  inline bool has_third_data() const;
  inline void clear_third_data();
  static const int kThirdDataFieldNumber = 6;
  inline const ::navi::VoiceRecog::ApiThirdData& third_data() const;
  inline ::navi::VoiceRecog::ApiThirdData* mutable_third_data();
  inline ::navi::VoiceRecog::ApiThirdData* release_third_data();
  inline void set_allocated_third_data(::navi::VoiceRecog::ApiThirdData* third_data);

  // optional .navi.VoiceRecog.ApiHeart heart = 7;
  inline bool has_heart() const;
  inline void clear_heart();
  static const int kHeartFieldNumber = 7;
  inline const ::navi::VoiceRecog::ApiHeart& heart() const;
  inline ::navi::VoiceRecog::ApiHeart* mutable_heart();
  inline ::navi::VoiceRecog::ApiHeart* release_heart();
  inline void set_allocated_heart(::navi::VoiceRecog::ApiHeart* heart);

  // optional .navi.VoiceRecog.ApiLast last = 8;
  inline bool has_last() const;
  inline void clear_last();
  static const int kLastFieldNumber = 8;
  inline const ::navi::VoiceRecog::ApiLast& last() const;
  inline ::navi::VoiceRecog::ApiLast* mutable_last();
  inline ::navi::VoiceRecog::ApiLast* release_last();
  inline void set_allocated_last(::navi::VoiceRecog::ApiLast* last);

  // @@protoc_insertion_point(class_scope:navi.VoiceRecog.APIResponse)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_err_no();
  inline void clear_has_err_no();
  inline void set_has_err_msg();
  inline void clear_has_err_msg();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_third_data();
  inline void clear_has_third_data();
  inline void set_has_heart();
  inline void clear_has_heart();
  inline void set_has_last();
  inline void clear_has_last();

  ::std::string* id_;
  int type_;
  ::google::protobuf::int32 err_no_;
  ::std::string* err_msg_;
  ::navi::VoiceRecog::ASRResult* result_;
  ::navi::VoiceRecog::ApiThirdData* third_data_;
  ::navi::VoiceRecog::ApiHeart* heart_;
  ::navi::VoiceRecog::ApiLast* last_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_VrSmartHomeData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_VrSmartHomeData_2eproto();
  #endif
  friend void protobuf_AssignDesc_VrSmartHomeData_2eproto();
  friend void protobuf_ShutdownFile_VrSmartHomeData_2eproto();

  void InitAsDefaultInstance();
  static APIResponse* default_instance_;
};
// -------------------------------------------------------------------

class ASRResult : public ::google::protobuf::MessageLite {
 public:
  ASRResult();
  virtual ~ASRResult();

  ASRResult(const ASRResult& from);

  inline ASRResult& operator=(const ASRResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const ASRResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ASRResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ASRResult* other);

  // implements Message ----------------------------------------------

  ASRResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ASRResult& from);
  void MergeFrom(const ASRResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string word = 1;
  inline int word_size() const;
  inline void clear_word();
  static const int kWordFieldNumber = 1;
  inline const ::std::string& word(int index) const;
  inline ::std::string* mutable_word(int index);
  inline void set_word(int index, const ::std::string& value);
  inline void set_word(int index, const char* value);
  inline void set_word(int index, const char* value, size_t size);
  inline ::std::string* add_word();
  inline void add_word(const ::std::string& value);
  inline void add_word(const char* value);
  inline void add_word(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& word() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_word();

  // repeated string uncertain_word = 2;
  inline int uncertain_word_size() const;
  inline void clear_uncertain_word();
  static const int kUncertainWordFieldNumber = 2;
  inline const ::std::string& uncertain_word(int index) const;
  inline ::std::string* mutable_uncertain_word(int index);
  inline void set_uncertain_word(int index, const ::std::string& value);
  inline void set_uncertain_word(int index, const char* value);
  inline void set_uncertain_word(int index, const char* value, size_t size);
  inline ::std::string* add_uncertain_word();
  inline void add_uncertain_word(const ::std::string& value);
  inline void add_uncertain_word(const char* value);
  inline void add_uncertain_word(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& uncertain_word() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_uncertain_word();

  // @@protoc_insertion_point(class_scope:navi.VoiceRecog.ASRResult)
 private:

  ::google::protobuf::RepeatedPtrField< ::std::string> word_;
  ::google::protobuf::RepeatedPtrField< ::std::string> uncertain_word_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_VrSmartHomeData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_VrSmartHomeData_2eproto();
  #endif
  friend void protobuf_AssignDesc_VrSmartHomeData_2eproto();
  friend void protobuf_ShutdownFile_VrSmartHomeData_2eproto();

  void InitAsDefaultInstance();
  static ASRResult* default_instance_;
};
// ===================================================================


// ===================================================================

// APIRequest

// required .navi.VoiceRecog.APIReqType api_req_type = 1;
inline bool APIRequest::has_api_req_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void APIRequest::set_has_api_req_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void APIRequest::clear_has_api_req_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void APIRequest::clear_api_req_type() {
  api_req_type_ = 1;
  clear_has_api_req_type();
}
inline ::navi::VoiceRecog::APIReqType APIRequest::api_req_type() const {
  return static_cast< ::navi::VoiceRecog::APIReqType >(api_req_type_);
}
inline void APIRequest::set_api_req_type(::navi::VoiceRecog::APIReqType value) {
  assert(::navi::VoiceRecog::APIReqType_IsValid(value));
  set_has_api_req_type();
  api_req_type_ = value;
}

// optional .navi.VoiceRecog.ApiParam param = 2;
inline bool APIRequest::has_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void APIRequest::set_has_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void APIRequest::clear_has_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void APIRequest::clear_param() {
  if (param_ != NULL) param_->::navi::VoiceRecog::ApiParam::Clear();
  clear_has_param();
}
inline const ::navi::VoiceRecog::ApiParam& APIRequest::param() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return param_ != NULL ? *param_ : *default_instance().param_;
#else
  return param_ != NULL ? *param_ : *default_instance_->param_;
#endif
}
inline ::navi::VoiceRecog::ApiParam* APIRequest::mutable_param() {
  set_has_param();
  if (param_ == NULL) param_ = new ::navi::VoiceRecog::ApiParam;
  return param_;
}
inline ::navi::VoiceRecog::ApiParam* APIRequest::release_param() {
  clear_has_param();
  ::navi::VoiceRecog::ApiParam* temp = param_;
  param_ = NULL;
  return temp;
}
inline void APIRequest::set_allocated_param(::navi::VoiceRecog::ApiParam* param) {
  delete param_;
  param_ = param;
  if (param) {
    set_has_param();
  } else {
    clear_has_param();
  }
}

// optional .navi.VoiceRecog.ApiData data = 3;
inline bool APIRequest::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void APIRequest::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void APIRequest::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void APIRequest::clear_data() {
  if (data_ != NULL) data_->::navi::VoiceRecog::ApiData::Clear();
  clear_has_data();
}
inline const ::navi::VoiceRecog::ApiData& APIRequest::data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return data_ != NULL ? *data_ : *default_instance().data_;
#else
  return data_ != NULL ? *data_ : *default_instance_->data_;
#endif
}
inline ::navi::VoiceRecog::ApiData* APIRequest::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::navi::VoiceRecog::ApiData;
  return data_;
}
inline ::navi::VoiceRecog::ApiData* APIRequest::release_data() {
  clear_has_data();
  ::navi::VoiceRecog::ApiData* temp = data_;
  data_ = NULL;
  return temp;
}
inline void APIRequest::set_allocated_data(::navi::VoiceRecog::ApiData* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// optional .navi.VoiceRecog.ApiLast last = 4;
inline bool APIRequest::has_last() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void APIRequest::set_has_last() {
  _has_bits_[0] |= 0x00000008u;
}
inline void APIRequest::clear_has_last() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void APIRequest::clear_last() {
  if (last_ != NULL) last_->::navi::VoiceRecog::ApiLast::Clear();
  clear_has_last();
}
inline const ::navi::VoiceRecog::ApiLast& APIRequest::last() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return last_ != NULL ? *last_ : *default_instance().last_;
#else
  return last_ != NULL ? *last_ : *default_instance_->last_;
#endif
}
inline ::navi::VoiceRecog::ApiLast* APIRequest::mutable_last() {
  set_has_last();
  if (last_ == NULL) last_ = new ::navi::VoiceRecog::ApiLast;
  return last_;
}
inline ::navi::VoiceRecog::ApiLast* APIRequest::release_last() {
  clear_has_last();
  ::navi::VoiceRecog::ApiLast* temp = last_;
  last_ = NULL;
  return temp;
}
inline void APIRequest::set_allocated_last(::navi::VoiceRecog::ApiLast* last) {
  delete last_;
  last_ = last;
  if (last) {
    set_has_last();
  } else {
    clear_has_last();
  }
}

// optional .navi.VoiceRecog.ApiCancel cancel = 5;
inline bool APIRequest::has_cancel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void APIRequest::set_has_cancel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void APIRequest::clear_has_cancel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void APIRequest::clear_cancel() {
  if (cancel_ != NULL) cancel_->::navi::VoiceRecog::ApiCancel::Clear();
  clear_has_cancel();
}
inline const ::navi::VoiceRecog::ApiCancel& APIRequest::cancel() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cancel_ != NULL ? *cancel_ : *default_instance().cancel_;
#else
  return cancel_ != NULL ? *cancel_ : *default_instance_->cancel_;
#endif
}
inline ::navi::VoiceRecog::ApiCancel* APIRequest::mutable_cancel() {
  set_has_cancel();
  if (cancel_ == NULL) cancel_ = new ::navi::VoiceRecog::ApiCancel;
  return cancel_;
}
inline ::navi::VoiceRecog::ApiCancel* APIRequest::release_cancel() {
  clear_has_cancel();
  ::navi::VoiceRecog::ApiCancel* temp = cancel_;
  cancel_ = NULL;
  return temp;
}
inline void APIRequest::set_allocated_cancel(::navi::VoiceRecog::ApiCancel* cancel) {
  delete cancel_;
  cancel_ = cancel;
  if (cancel) {
    set_has_cancel();
  } else {
    clear_has_cancel();
  }
}

// optional .navi.VoiceRecog.ApiThirdData third_data = 6;
inline bool APIRequest::has_third_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void APIRequest::set_has_third_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void APIRequest::clear_has_third_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void APIRequest::clear_third_data() {
  if (third_data_ != NULL) third_data_->::navi::VoiceRecog::ApiThirdData::Clear();
  clear_has_third_data();
}
inline const ::navi::VoiceRecog::ApiThirdData& APIRequest::third_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return third_data_ != NULL ? *third_data_ : *default_instance().third_data_;
#else
  return third_data_ != NULL ? *third_data_ : *default_instance_->third_data_;
#endif
}
inline ::navi::VoiceRecog::ApiThirdData* APIRequest::mutable_third_data() {
  set_has_third_data();
  if (third_data_ == NULL) third_data_ = new ::navi::VoiceRecog::ApiThirdData;
  return third_data_;
}
inline ::navi::VoiceRecog::ApiThirdData* APIRequest::release_third_data() {
  clear_has_third_data();
  ::navi::VoiceRecog::ApiThirdData* temp = third_data_;
  third_data_ = NULL;
  return temp;
}
inline void APIRequest::set_allocated_third_data(::navi::VoiceRecog::ApiThirdData* third_data) {
  delete third_data_;
  third_data_ = third_data;
  if (third_data) {
    set_has_third_data();
  } else {
    clear_has_third_data();
  }
}

// -------------------------------------------------------------------

// ApiParam

// required int32 sample_rate = 1;
inline bool ApiParam::has_sample_rate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApiParam::set_has_sample_rate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApiParam::clear_has_sample_rate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApiParam::clear_sample_rate() {
  sample_rate_ = 0;
  clear_has_sample_rate();
}
inline ::google::protobuf::int32 ApiParam::sample_rate() const {
  return sample_rate_;
}
inline void ApiParam::set_sample_rate(::google::protobuf::int32 value) {
  set_has_sample_rate();
  sample_rate_ = value;
}

// required string format = 2;
inline bool ApiParam::has_format() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApiParam::set_has_format() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApiParam::clear_has_format() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApiParam::clear_format() {
  if (format_ != &::google::protobuf::internal::kEmptyString) {
    format_->clear();
  }
  clear_has_format();
}
inline const ::std::string& ApiParam::format() const {
  return *format_;
}
inline void ApiParam::set_format(const ::std::string& value) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void ApiParam::set_format(const char* value) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(value);
}
inline void ApiParam::set_format(const char* value, size_t size) {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  format_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApiParam::mutable_format() {
  set_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    format_ = new ::std::string;
  }
  return format_;
}
inline ::std::string* ApiParam::release_format() {
  clear_has_format();
  if (format_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = format_;
    format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ApiParam::set_allocated_format(::std::string* format) {
  if (format_ != &::google::protobuf::internal::kEmptyString) {
    delete format_;
  }
  if (format) {
    set_has_format();
    format_ = format;
  } else {
    clear_has_format();
    format_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool early_return = 3;
inline bool ApiParam::has_early_return() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApiParam::set_has_early_return() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApiParam::clear_has_early_return() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApiParam::clear_early_return() {
  early_return_ = false;
  clear_has_early_return();
}
inline bool ApiParam::early_return() const {
  return early_return_;
}
inline void ApiParam::set_early_return(bool value) {
  set_has_early_return();
  early_return_ = value;
}

// required string imei = 4;
inline bool ApiParam::has_imei() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApiParam::set_has_imei() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ApiParam::clear_has_imei() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ApiParam::clear_imei() {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& ApiParam::imei() const {
  return *imei_;
}
inline void ApiParam::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void ApiParam::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void ApiParam::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApiParam::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  return imei_;
}
inline ::std::string* ApiParam::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ApiParam::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 home_link_type = 5;
inline bool ApiParam::has_home_link_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ApiParam::set_has_home_link_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ApiParam::clear_has_home_link_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ApiParam::clear_home_link_type() {
  home_link_type_ = 0;
  clear_has_home_link_type();
}
inline ::google::protobuf::int32 ApiParam::home_link_type() const {
  return home_link_type_;
}
inline void ApiParam::set_home_link_type(::google::protobuf::int32 value) {
  set_has_home_link_type();
  home_link_type_ = value;
}

// required string asr_backend_type = 6;
inline bool ApiParam::has_asr_backend_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ApiParam::set_has_asr_backend_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ApiParam::clear_has_asr_backend_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ApiParam::clear_asr_backend_type() {
  if (asr_backend_type_ != &::google::protobuf::internal::kEmptyString) {
    asr_backend_type_->clear();
  }
  clear_has_asr_backend_type();
}
inline const ::std::string& ApiParam::asr_backend_type() const {
  return *asr_backend_type_;
}
inline void ApiParam::set_asr_backend_type(const ::std::string& value) {
  set_has_asr_backend_type();
  if (asr_backend_type_ == &::google::protobuf::internal::kEmptyString) {
    asr_backend_type_ = new ::std::string;
  }
  asr_backend_type_->assign(value);
}
inline void ApiParam::set_asr_backend_type(const char* value) {
  set_has_asr_backend_type();
  if (asr_backend_type_ == &::google::protobuf::internal::kEmptyString) {
    asr_backend_type_ = new ::std::string;
  }
  asr_backend_type_->assign(value);
}
inline void ApiParam::set_asr_backend_type(const char* value, size_t size) {
  set_has_asr_backend_type();
  if (asr_backend_type_ == &::google::protobuf::internal::kEmptyString) {
    asr_backend_type_ = new ::std::string;
  }
  asr_backend_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApiParam::mutable_asr_backend_type() {
  set_has_asr_backend_type();
  if (asr_backend_type_ == &::google::protobuf::internal::kEmptyString) {
    asr_backend_type_ = new ::std::string;
  }
  return asr_backend_type_;
}
inline ::std::string* ApiParam::release_asr_backend_type() {
  clear_has_asr_backend_type();
  if (asr_backend_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = asr_backend_type_;
    asr_backend_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ApiParam::set_allocated_asr_backend_type(::std::string* asr_backend_type) {
  if (asr_backend_type_ != &::google::protobuf::internal::kEmptyString) {
    delete asr_backend_type_;
  }
  if (asr_backend_type) {
    set_has_asr_backend_type();
    asr_backend_type_ = asr_backend_type;
  } else {
    clear_has_asr_backend_type();
    asr_backend_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ApiData

// required uint32 len = 1;
inline bool ApiData::has_len() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApiData::set_has_len() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApiData::clear_has_len() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApiData::clear_len() {
  len_ = 0u;
  clear_has_len();
}
inline ::google::protobuf::uint32 ApiData::len() const {
  return len_;
}
inline void ApiData::set_len(::google::protobuf::uint32 value) {
  set_has_len();
  len_ = value;
}

// required bytes post_data = 2;
inline bool ApiData::has_post_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApiData::set_has_post_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApiData::clear_has_post_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApiData::clear_post_data() {
  if (post_data_ != &::google::protobuf::internal::kEmptyString) {
    post_data_->clear();
  }
  clear_has_post_data();
}
inline const ::std::string& ApiData::post_data() const {
  return *post_data_;
}
inline void ApiData::set_post_data(const ::std::string& value) {
  set_has_post_data();
  if (post_data_ == &::google::protobuf::internal::kEmptyString) {
    post_data_ = new ::std::string;
  }
  post_data_->assign(value);
}
inline void ApiData::set_post_data(const char* value) {
  set_has_post_data();
  if (post_data_ == &::google::protobuf::internal::kEmptyString) {
    post_data_ = new ::std::string;
  }
  post_data_->assign(value);
}
inline void ApiData::set_post_data(const void* value, size_t size) {
  set_has_post_data();
  if (post_data_ == &::google::protobuf::internal::kEmptyString) {
    post_data_ = new ::std::string;
  }
  post_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApiData::mutable_post_data() {
  set_has_post_data();
  if (post_data_ == &::google::protobuf::internal::kEmptyString) {
    post_data_ = new ::std::string;
  }
  return post_data_;
}
inline ::std::string* ApiData::release_post_data() {
  clear_has_post_data();
  if (post_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = post_data_;
    post_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ApiData::set_allocated_post_data(::std::string* post_data) {
  if (post_data_ != &::google::protobuf::internal::kEmptyString) {
    delete post_data_;
  }
  if (post_data) {
    set_has_post_data();
    post_data_ = post_data;
  } else {
    clear_has_post_data();
    post_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ApiLast

// -------------------------------------------------------------------

// ApiHeart

// -------------------------------------------------------------------

// ApiCancel

// -------------------------------------------------------------------

// ApiThirdData

// required uint32 len = 1;
inline bool ApiThirdData::has_len() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApiThirdData::set_has_len() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApiThirdData::clear_has_len() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApiThirdData::clear_len() {
  len_ = 0u;
  clear_has_len();
}
inline ::google::protobuf::uint32 ApiThirdData::len() const {
  return len_;
}
inline void ApiThirdData::set_len(::google::protobuf::uint32 value) {
  set_has_len();
  len_ = value;
}

// required bytes third_data = 2;
inline bool ApiThirdData::has_third_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApiThirdData::set_has_third_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApiThirdData::clear_has_third_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApiThirdData::clear_third_data() {
  if (third_data_ != &::google::protobuf::internal::kEmptyString) {
    third_data_->clear();
  }
  clear_has_third_data();
}
inline const ::std::string& ApiThirdData::third_data() const {
  return *third_data_;
}
inline void ApiThirdData::set_third_data(const ::std::string& value) {
  set_has_third_data();
  if (third_data_ == &::google::protobuf::internal::kEmptyString) {
    third_data_ = new ::std::string;
  }
  third_data_->assign(value);
}
inline void ApiThirdData::set_third_data(const char* value) {
  set_has_third_data();
  if (third_data_ == &::google::protobuf::internal::kEmptyString) {
    third_data_ = new ::std::string;
  }
  third_data_->assign(value);
}
inline void ApiThirdData::set_third_data(const void* value, size_t size) {
  set_has_third_data();
  if (third_data_ == &::google::protobuf::internal::kEmptyString) {
    third_data_ = new ::std::string;
  }
  third_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApiThirdData::mutable_third_data() {
  set_has_third_data();
  if (third_data_ == &::google::protobuf::internal::kEmptyString) {
    third_data_ = new ::std::string;
  }
  return third_data_;
}
inline ::std::string* ApiThirdData::release_third_data() {
  clear_has_third_data();
  if (third_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = third_data_;
    third_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ApiThirdData::set_allocated_third_data(::std::string* third_data) {
  if (third_data_ != &::google::protobuf::internal::kEmptyString) {
    delete third_data_;
  }
  if (third_data) {
    set_has_third_data();
    third_data_ = third_data;
  } else {
    clear_has_third_data();
    third_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 3;
inline bool ApiThirdData::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApiThirdData::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApiThirdData::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApiThirdData::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& ApiThirdData::type() const {
  return *type_;
}
inline void ApiThirdData::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ApiThirdData::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ApiThirdData::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApiThirdData::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* ApiThirdData::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ApiThirdData::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// APIResponse

// required .navi.VoiceRecog.APIRespType type = 1;
inline bool APIResponse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void APIResponse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void APIResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void APIResponse::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::navi::VoiceRecog::APIRespType APIResponse::type() const {
  return static_cast< ::navi::VoiceRecog::APIRespType >(type_);
}
inline void APIResponse::set_type(::navi::VoiceRecog::APIRespType value) {
  assert(::navi::VoiceRecog::APIRespType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string id = 2;
inline bool APIResponse::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void APIResponse::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void APIResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void APIResponse::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& APIResponse::id() const {
  return *id_;
}
inline void APIResponse::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void APIResponse::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void APIResponse::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* APIResponse::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* APIResponse::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void APIResponse::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 err_no = 3;
inline bool APIResponse::has_err_no() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void APIResponse::set_has_err_no() {
  _has_bits_[0] |= 0x00000004u;
}
inline void APIResponse::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void APIResponse::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::google::protobuf::int32 APIResponse::err_no() const {
  return err_no_;
}
inline void APIResponse::set_err_no(::google::protobuf::int32 value) {
  set_has_err_no();
  err_no_ = value;
}

// optional string err_msg = 4;
inline bool APIResponse::has_err_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void APIResponse::set_has_err_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void APIResponse::clear_has_err_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void APIResponse::clear_err_msg() {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    err_msg_->clear();
  }
  clear_has_err_msg();
}
inline const ::std::string& APIResponse::err_msg() const {
  return *err_msg_;
}
inline void APIResponse::set_err_msg(const ::std::string& value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void APIResponse::set_err_msg(const char* value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void APIResponse::set_err_msg(const char* value, size_t size) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* APIResponse::mutable_err_msg() {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  return err_msg_;
}
inline ::std::string* APIResponse::release_err_msg() {
  clear_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_msg_;
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void APIResponse::set_allocated_err_msg(::std::string* err_msg) {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete err_msg_;
  }
  if (err_msg) {
    set_has_err_msg();
    err_msg_ = err_msg;
  } else {
    clear_has_err_msg();
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .navi.VoiceRecog.ASRResult result = 5;
inline bool APIResponse::has_result() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void APIResponse::set_has_result() {
  _has_bits_[0] |= 0x00000010u;
}
inline void APIResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void APIResponse::clear_result() {
  if (result_ != NULL) result_->::navi::VoiceRecog::ASRResult::Clear();
  clear_has_result();
}
inline const ::navi::VoiceRecog::ASRResult& APIResponse::result() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return result_ != NULL ? *result_ : *default_instance().result_;
#else
  return result_ != NULL ? *result_ : *default_instance_->result_;
#endif
}
inline ::navi::VoiceRecog::ASRResult* APIResponse::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::navi::VoiceRecog::ASRResult;
  return result_;
}
inline ::navi::VoiceRecog::ASRResult* APIResponse::release_result() {
  clear_has_result();
  ::navi::VoiceRecog::ASRResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void APIResponse::set_allocated_result(::navi::VoiceRecog::ASRResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional .navi.VoiceRecog.ApiThirdData third_data = 6;
inline bool APIResponse::has_third_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void APIResponse::set_has_third_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void APIResponse::clear_has_third_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void APIResponse::clear_third_data() {
  if (third_data_ != NULL) third_data_->::navi::VoiceRecog::ApiThirdData::Clear();
  clear_has_third_data();
}
inline const ::navi::VoiceRecog::ApiThirdData& APIResponse::third_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return third_data_ != NULL ? *third_data_ : *default_instance().third_data_;
#else
  return third_data_ != NULL ? *third_data_ : *default_instance_->third_data_;
#endif
}
inline ::navi::VoiceRecog::ApiThirdData* APIResponse::mutable_third_data() {
  set_has_third_data();
  if (third_data_ == NULL) third_data_ = new ::navi::VoiceRecog::ApiThirdData;
  return third_data_;
}
inline ::navi::VoiceRecog::ApiThirdData* APIResponse::release_third_data() {
  clear_has_third_data();
  ::navi::VoiceRecog::ApiThirdData* temp = third_data_;
  third_data_ = NULL;
  return temp;
}
inline void APIResponse::set_allocated_third_data(::navi::VoiceRecog::ApiThirdData* third_data) {
  delete third_data_;
  third_data_ = third_data;
  if (third_data) {
    set_has_third_data();
  } else {
    clear_has_third_data();
  }
}

// optional .navi.VoiceRecog.ApiHeart heart = 7;
inline bool APIResponse::has_heart() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void APIResponse::set_has_heart() {
  _has_bits_[0] |= 0x00000040u;
}
inline void APIResponse::clear_has_heart() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void APIResponse::clear_heart() {
  if (heart_ != NULL) heart_->::navi::VoiceRecog::ApiHeart::Clear();
  clear_has_heart();
}
inline const ::navi::VoiceRecog::ApiHeart& APIResponse::heart() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return heart_ != NULL ? *heart_ : *default_instance().heart_;
#else
  return heart_ != NULL ? *heart_ : *default_instance_->heart_;
#endif
}
inline ::navi::VoiceRecog::ApiHeart* APIResponse::mutable_heart() {
  set_has_heart();
  if (heart_ == NULL) heart_ = new ::navi::VoiceRecog::ApiHeart;
  return heart_;
}
inline ::navi::VoiceRecog::ApiHeart* APIResponse::release_heart() {
  clear_has_heart();
  ::navi::VoiceRecog::ApiHeart* temp = heart_;
  heart_ = NULL;
  return temp;
}
inline void APIResponse::set_allocated_heart(::navi::VoiceRecog::ApiHeart* heart) {
  delete heart_;
  heart_ = heart;
  if (heart) {
    set_has_heart();
  } else {
    clear_has_heart();
  }
}

// optional .navi.VoiceRecog.ApiLast last = 8;
inline bool APIResponse::has_last() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void APIResponse::set_has_last() {
  _has_bits_[0] |= 0x00000080u;
}
inline void APIResponse::clear_has_last() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void APIResponse::clear_last() {
  if (last_ != NULL) last_->::navi::VoiceRecog::ApiLast::Clear();
  clear_has_last();
}
inline const ::navi::VoiceRecog::ApiLast& APIResponse::last() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return last_ != NULL ? *last_ : *default_instance().last_;
#else
  return last_ != NULL ? *last_ : *default_instance_->last_;
#endif
}
inline ::navi::VoiceRecog::ApiLast* APIResponse::mutable_last() {
  set_has_last();
  if (last_ == NULL) last_ = new ::navi::VoiceRecog::ApiLast;
  return last_;
}
inline ::navi::VoiceRecog::ApiLast* APIResponse::release_last() {
  clear_has_last();
  ::navi::VoiceRecog::ApiLast* temp = last_;
  last_ = NULL;
  return temp;
}
inline void APIResponse::set_allocated_last(::navi::VoiceRecog::ApiLast* last) {
  delete last_;
  last_ = last;
  if (last) {
    set_has_last();
  } else {
    clear_has_last();
  }
}

// -------------------------------------------------------------------

// ASRResult

// repeated string word = 1;
inline int ASRResult::word_size() const {
  return word_.size();
}
inline void ASRResult::clear_word() {
  word_.Clear();
}
inline const ::std::string& ASRResult::word(int index) const {
  return word_.Get(index);
}
inline ::std::string* ASRResult::mutable_word(int index) {
  return word_.Mutable(index);
}
inline void ASRResult::set_word(int index, const ::std::string& value) {
  word_.Mutable(index)->assign(value);
}
inline void ASRResult::set_word(int index, const char* value) {
  word_.Mutable(index)->assign(value);
}
inline void ASRResult::set_word(int index, const char* value, size_t size) {
  word_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRResult::add_word() {
  return word_.Add();
}
inline void ASRResult::add_word(const ::std::string& value) {
  word_.Add()->assign(value);
}
inline void ASRResult::add_word(const char* value) {
  word_.Add()->assign(value);
}
inline void ASRResult::add_word(const char* value, size_t size) {
  word_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ASRResult::word() const {
  return word_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ASRResult::mutable_word() {
  return &word_;
}

// repeated string uncertain_word = 2;
inline int ASRResult::uncertain_word_size() const {
  return uncertain_word_.size();
}
inline void ASRResult::clear_uncertain_word() {
  uncertain_word_.Clear();
}
inline const ::std::string& ASRResult::uncertain_word(int index) const {
  return uncertain_word_.Get(index);
}
inline ::std::string* ASRResult::mutable_uncertain_word(int index) {
  return uncertain_word_.Mutable(index);
}
inline void ASRResult::set_uncertain_word(int index, const ::std::string& value) {
  uncertain_word_.Mutable(index)->assign(value);
}
inline void ASRResult::set_uncertain_word(int index, const char* value) {
  uncertain_word_.Mutable(index)->assign(value);
}
inline void ASRResult::set_uncertain_word(int index, const char* value, size_t size) {
  uncertain_word_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ASRResult::add_uncertain_word() {
  return uncertain_word_.Add();
}
inline void ASRResult::add_uncertain_word(const ::std::string& value) {
  uncertain_word_.Add()->assign(value);
}
inline void ASRResult::add_uncertain_word(const char* value) {
  uncertain_word_.Add()->assign(value);
}
inline void ASRResult::add_uncertain_word(const char* value, size_t size) {
  uncertain_word_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ASRResult::uncertain_word() const {
  return uncertain_word_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ASRResult::mutable_uncertain_word() {
  return &uncertain_word_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace VoiceRecog
}  // namespace navi

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_VrSmartHomeData_2eproto__INCLUDED
